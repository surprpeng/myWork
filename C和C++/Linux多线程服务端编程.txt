- 线程安全的对象生命期管理
	- 对资源上锁
	- 不要在构造函数里注册任何回调函数，和把this指针传给其他对象。
	- 作为数据成员的mutex不能保护析构函数，应为析构函数会把mutex也销毁，其他线程会一直阻塞在获取锁的语句
	- 不要用原始指针，要用shared_ptr和weak_ptr
	- shared_ptr是引用计数型指针，能保证析构是安全的，但是读写并不是原子操作，所以需要加上锁。
	- weak_ptr用于解决”引用计数”模型循环依赖问题，weak_ptr指向一个对象，并不增减该对象的引用计数器。
		weak_ptr用于配合shared_ptr使用，并不影响动态对象的生命周期，即其存在与否并不影响对象的引用计数器。
		weak_ptr并没有重载operator->和operator *操作符，因此不可直接通过weak_ptr使用对象。
		weak_ptr提供了expired()与lock()成员函数，前者用于判断weak_ptr指向的对象是否已被销毁，
		后者返回其所指对象的shared_ptr智能指针(对象销毁时返回”空”shared_ptr)。
    - RAII 封装对象，如shared_ptr
- 线程同步
	- 互斥器（mutex）
		- 只使用非递归的mutex，即不可重入的mutex。
		- 对不可重入的锁上锁两次会造成死锁。
	- 条件变量
		- 等待某一条件，
		- wait端，必须与mutex一起使用。
		- 发送端，不一定要在上锁的情况下调用signal。
	- 用shared_ptr实现copy-on-write
		- 在read端，用栈上局部变量当做观测者，使得引用计数增加。
		- write端，如果没人在读，在原地上修改，如果有人在读，复制一份副本，在副本上修改。避免了死锁。
- IO模式
	- 阻塞
	- 非阻塞
	- IO多路复用（select，poll，epoll）
		- 一个进程能同时等待多个文件描述符，有一个就绪，就可以返回
		- epoll是前两者的增强版，没有描述符限制。
	- 异步IO
- 多线程程序中fork()后，子进程中只有一个线程，其他线程都消失了。
- 日志系统用的是异步日志，由单独的一个日志线程进行管理，采用双缓冲技术，将日志信息整合，buffer满了后再调用线程
	去写，减少了线程切换的开销。

