- 多用户系统：就是一台能并发和独立执行分别属于两个或多个用户的若干应用程序的计算机。
- 多用户系统中的进程必须是抢占式的。
- 系统调用或中断会使进程从用户态进入内核态
- 信号量可能很费时间，因为要将进程插入到信号量链表中。多处理器操作系统使用自旋锁。
- 自旋锁和信号量类似，但是不会将进程插入到链表当中去，而是不断地循环指令，直到锁打开。
	自旋锁在单处理器系统上是无效的。自旋锁不能被抢占、不能被中断。在单处理器上，内核控制路径就
	可能没机会执行，也没有机会释放这个自旋锁。
- 进程间通信：IPC机制：信号量、消息队列、共享内存
- 进程的状态：运行，可中断的等待状态，不可中断的等待状态，暂停状态，跟踪状态、
	僵死状态（进程的执行被中止，但是父进程还没有发布系统调用来返回死亡信息。内核中还包含
		僵死进程的进程描述符。）
- 引入僵死状态原因：尽管从技术上来说进程已经死亡，但必须保存它的描述符，知道父进程得到通知。
	如果父进程在子进程结束之前结束，那么系统会到处都是僵死进程，而且他们的进程描述符永远占据RAM
	，所以必须强迫所有的孤儿进程成为init进程的子进程来解决这个问题。
- 中断和异常：
	- 同步中断（异常）：指令执行，CPU产生的
	- 异步中断（中断）：有其他硬件设备依照时钟信号随机产生的。
	- 中断描述符表，存放对应中断的函数入口地址。
	- i/o中断，定时器中断，处理器中断
- 顺序锁，和自旋锁类似，但为写赋予更高的优先级，读和写可以同步进行，维护一个顺序计数器，
	每个读者读前后两次读取顺序计数器并检查两次是否相同若不同，则读到的数据无效。
- 进程调度，分时技术，和优先级
	- 普通进程：静态优先级越高，其值越小，基本时间片越长
	- 有两个集合：活动进程、过期进程
		- 为了避免进程饥饿，优先级再高，用完时间片，就应该放到过期进程中，直到活动进程都过期，再重新分配时间片
	- 实时进程
		- 不是基于时间片的实时进程总是处于活动进程，直到阻塞和被杀死
		- 基于时间片的实时进程和普通进程一样。
- 内存管理
	- 一个页框大小为4KB和4MB
	- 页描述符记录每个页框的当前状态
	- fork进程，写时服用
	- 信号是通知某个事件的手段（内核态的通信）
	- 页 》 段 》 块 》 扇区
	- 内存中修改数据的页叫做脏页，需要替换磁盘中的内容
- 进程通信
	- 管道和FIFO（命名管道）
		- 单向，半双工，
		- 管道被看作是打开的文件，但是没有相应的文件映射。
		- 无法打开已经存在的管道。这就使得任意两个进程不可能共享同一管道，除非进程由一个个公共祖先进程创建
		- FIFO或命名管道解决上述问题，任何进程都可以访问FIFO。
	- 信号量（和消息、共享内存统称为IPC）： 提供一种互斥的机制，对数据进行保护。
		- 每个IPC信号量都是一个或多个信号量的集合，
		- 内核为每个IPC信号量都分配一个挂起请求队列
	- 消息
		- 维护一个消息队列
	- 消息队列
		- 很像消息，但是是有很多优点。
		- 简单，支持消息优先级，异步通知，用于阻塞发送与接收操作的超时机制
		- 
	- 共享内存区
		- 将公共数据放在共享内存区中，
		- 要使用里面的数据，每个进程都需要增加一个新内存区，它将映射与共享内存区相关的页框。
		- 
	- 套接字
操作系统
1、内存碎片
	- 外碎片：系统为应用程序分配内存产生的碎片；
	- 内碎片：应用程序已经获得内存空间，但是有些空间不能使用；
2、（连续）内存分配策略：首次适配；最优适配；最差适配。
	压缩式碎片管理：挪动应用程序在内存空间中的位置；
	交换式碎片管理（swaping）：内存空间已经满了，抢占等待的程序，回收它们的内存。
					将数据在内存和硬盘之间换入换出。
3、非连续内存分配：建立虚拟地址和物理地址之间的转换
	硬件方案：分段：寻址方式：段地址+偏移地址
			  分页：页的大小固定，段的大小可变；物理地址寻址：页帧号（Frame）+偏移地址。
								物理地址寻址：页号（Page）+偏移地址。
	页表（page table）:index is Frame number.context is Page number.theis offset address are same.
	TLB(缓冲)位于CPU内，快表。把经常访问的页表项放入TLB，提高访问速度。
	二级页表、多级页表可以解决空间问题。 （反向页表）
4、覆盖技术，不会同时执行的程序函数（模块）共享一块内存空间。（由程序员调整覆盖结构）
	交换技术，以进程为单位进行导入导出硬盘，由操作系统完成。
	虚存技术，类似覆盖技术，但由操作系统完成，以page为单位。
		- 要求程序局部性：指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定的区域。 
		- 将部分需要执行的代码放到内存中，接下来需要访问的数据在硬盘中，会触发缺页异常,将数据导入或交换。
		- 请求调页:之装入部分页面，运行时找不到数据时再发请求。
5、页面置换算法：
	局部页面置换算法：
		最优页面置换算法：置换将来不会访问的页。需要知道未来的情况。无法实现。可以当其他算法性能的依据。
		先进先出算法（FIFO）：性能差。
		最近最久未使用算法（LRU）:开销大，需要维护一个链表或stack，查找效率低。
		时钟页面置换算法：通过访问位超找需要置换的页，所有页表组成一个环形链表
						指针过访问位为1的时候，将其清0；访问位硬件可自动至1，软件可清零。
						加入脏位（dirty bit），替换脏页，置换只读过得页面，这样就直接清除页，不用替换回硬盘。
		最不常用算法（LFU）：选择访问次数最少的页面置换掉。
		belady现象：FIFO算法，分配的物理页数增加，缺页率反而提高的异常现象。
	全局页面置换算法：从整个操作系统层面，减少多个程序的缺页中断。
			工作集页置换算法：工作集窗口长度固定，随着时间挪动，即使没有产生缺页，也会将没有在工作集中的页删除。
			缺页率页面置换算法：增加缺页率大的进程的物理页大小。
6、PCB进程控制块：
	进程标识信息：本进程标识，父进程标识
	用户可见寄存器，控制和状态寄存器，栈指针。
	控制信息：调度状态信息，进程间通信信息，存储管理信息，进程所有资源，有关数据结构连接信息。
7、进程生命周期
	进程等待（阻塞）：进程只能自己阻塞自己。
	进程唤醒：阻塞事件满足，进程进入运行态。
	进程结束：正常退出，错误退出，致命错误，被其他进程杀死。
	运行态，就绪态，等待状态。
	进程挂起：进程没有占用内存空间，阻塞挂起；就绪挂起；
	状态队列：一组管理数据结构
8、线程管理： 线程 = 进程 - 共享资源
	线程控制块（TCB）：
	用户线程：操作系统看不到，由线程库管理，如果一个线程阻塞，整个进程等待。当一个线程开始运行后，除非它主动地交出CPU
				的使用权，否则它所在的进程当中的其他线程将无法运行。
	内核线程：由操作线系统管理。进程完成资源管理，线程完成调度管理。（windows）
	轻量级进程：（linux）
9、int pid = fork();
	if(pid == 0){
		exec("/bin/calc"); //加载执行应用程序，并覆盖父进程的所有资源。
	} //子进程在这里执行
	else if (pid > 0){          //父进程在这里继续
		wait(pid);//pid为子进程号
	} 
	上述代码开销大，因为fork(),复制父进程的所有内存空间，但执行exec()后，又需要重新覆盖这些内容，造成可不必要的开销。
	vfork(),不需要创建一个同样的内存映像。
	copy on write技术，只是复制一些页表，数据不复制，当子进程或父进程写的时候再进行内存复制。
	wait();//父进程必须等待子进程执行完毕。子进程退出，但是PCB不能回收，这个由父进程完成PCB的释放。 
	僵尸态：进程结束调用exit()后，释放内存，但是PCB还存在，这时候需要检查父进程是否存在，若存在，wait()没有
			执行完毕，这个时间段的子进程就是出于僵尸状态。若父进程先被杀死，操作系统会定期清除僵尸进程。
10、调度：
		不可抢占：调度程序必须等待时间结束。
		可以抢占：
	FCFS(先来先服务调度)
	SPN SRT（短进程优先）：根据执行时间进行优先排序，需要预估未来，
	HRRN （最高响应比优先）：考虑等待时间和执行时间
	RR 轮询调度算法： 额外的上下文切换，时间片大小需要选择。
	MLFQ多级反馈队列：动态调整优先级
	FSS公平共享调度算法： 
	优先级反转，优先级继承，
11、原子操作，临界区，互斥，死锁，饥饿
	临界区： 禁用中断 -> 进入临界区 -> 开启中断 ; 只针对临界区执行时间很小，如果有多个CPU，这种方式失效。
			 flag[i] = ture;
			 turn = j;
			 while(flag[i]&&turn==j);
			 //临界区
			 flag[i] = flase; 
	原子指令：test and set //查看某位和将某位置1
			  exchange     //交换两位的值
	死锁：高优先级在等待资源，但低优先级进程却得不到执行而无法释放资源，导致死锁。
12、信号量：
		一个整形，两个原子操作,P():sem-1，如果sem<0,等待；V():sem+1,如果sem<=0,唤醒一个等待的P。
		实现：等待队列
	管程：需要lock， wait(),signal()。条件互斥。
13、死锁
		特征：（必要条件）互斥：持有并等待：无抢占：循环等待：
		处理办法： 死锁避免，死锁预防，开销大。
			死锁避免算法（银行家算法）：假设分配资源后，执行序列是否是安全的，若非安全则不能接受资源请求。
			死锁检测算法：判断进程等待图是否有环。
			死锁恢复算法：
14、信号（Signal）：管道：；例：% ls | more //ls的输出到more的输入。
	消息队列：共享内存：
15、文件系统：磁盘单位扇区， 
		文件描述符：
		虚拟文件系统：操作系统屏蔽了具体文件系统的差异性。
			


	