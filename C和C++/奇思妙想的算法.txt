1、数组中重复的数字： 时间复杂度O(n),空间复杂度O(1)
	扫描数组，当i != nums[i] ,若相等则继续扫描，若不等，判断nums[i] == nums[nums[i]] ,
	若相等则找到，若不等，交换两个数继续扫描。
2、构造回文：给定一个字符串，求最少删除多少个字符，可以使字符串变为一个回文串
	时间复杂度O(n^2),空间复杂度O(n^2)
	step1:翻转字符串，将问题变成求0两个字符串最大公共子序列；
	step2：用动态规划， if(s1[i] == s2[j]) dp[i][j] = dp[i-1][j-1] +1;
						else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
3、